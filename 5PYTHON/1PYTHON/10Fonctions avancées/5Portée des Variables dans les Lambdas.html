<!DOCTYPE html><html><head><meta charSet="utf-8"/><link rel="apple-touch-icon" sizes="180x180" href="https://cdn.oaistatic.com/_next/static/media/apple-touch-icon.59f2e898.png"/><link rel="icon" type="image/png" sizes="32x32" href="https://cdn.oaistatic.com/_next/static/media/favicon-32x32.be48395e.png"/><link rel="icon" type="image/png" sizes="16x16" href="https://cdn.oaistatic.com/_next/static/media/favicon-16x16.9b8dbb69.png"/><link rel="preconnect" href="https://cdn.oaistatic.com"/><title>ChatGPT</title><meta name="title" content="ChatGPT: Get instant answers, find inspiration, learn something new"/><meta name="description" content="ChatGPT is a free-to-use AI system. Use it for engaging conversations, gain insights, automate tasks, and witness the future of AI, all in one place."/><meta name="keywords" content="ai chat,ai,chap gpt,chat gbt,chat gpt 3,chat gpt login,chat gpt website,chat gpt,chat gtp,chat openai,chat,chatai,chatbot gpt,chatg,chatgpt login,chatgpt,gpt chat,open ai,openai chat,openai chatgpt,openai"/><meta property="og:description" content="A conversational AI system that listens, learns, and challenges"/><meta name="robots" content="index, follow"/><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta property="og:title" content="ChatGPT"/><meta property="og:image" content="https://cdn.oaistatic.com/_next/static/media/chatgpt-share-og.49cbbffe.png"/><meta property="og:url" content="https://chat.openai.com"/><meta name="apple-itunes-app" content="app-id=6448311069"/><meta name="next-head-count" content="17"/><link rel="preload" href="https://cdn.oaistatic.com/_next/static/media/soehne-buch.13189857.woff2" as="font" crossorigin=""/><link rel="preload" href="https://cdn.oaistatic.com/_next/static/media/soehne-halbfett.977f1845.woff2" as="font" crossorigin=""/><link rel="preload" href="https://cdn.oaistatic.com/_next/static/media/soehne-mono-buch.de677af1.woff2" as="font" crossorigin=""/><link rel="preload" href="https://cdn.oaistatic.com/_next/static/media/soehne-mono-halbfett.b082e8e2.woff2" as="font" crossorigin=""/><link data-next-font="" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="https://cdn.oaistatic.com/_next/static/css/1bca5ee9d7f86daa.css" as="style" crossorigin="anonymous"/><link rel="stylesheet" href="https://cdn.oaistatic.com/_next/static/css/1bca5ee9d7f86daa.css" crossorigin="anonymous" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="anonymous" nomodule="" src="https://cdn.oaistatic.com/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="https://cdn.oaistatic.com/_next/static/chunks/webpack-c19ea191bfe97e1d.js" defer="" crossorigin="anonymous"></script><script src="https://cdn.oaistatic.com/_next/static/chunks/framework-31ffa51d236da229.js" defer="" crossorigin="anonymous"></script><script src="https://cdn.oaistatic.com/_next/static/chunks/main-6da2aad3a6c32aae.js" defer="" crossorigin="anonymous"></script><script src="https://cdn.oaistatic.com/_next/static/chunks/pages/_app-dfbd5fe22b2a2375.js" defer="" crossorigin="anonymous"></script><script src="https://cdn.oaistatic.com/_next/static/chunks/pages/share/%5B%5B...shareParams%5D%5D-d56de3ae0710acd6.js" defer="" crossorigin="anonymous"></script><script src="https://cdn.oaistatic.com/_next/static/HcJr3AWz9pJF9a2HyS6Cf/_buildManifest.js" defer="" crossorigin="anonymous"></script><script src="https://cdn.oaistatic.com/_next/static/HcJr3AWz9pJF9a2HyS6Cf/_ssgManifest.js" defer="" crossorigin="anonymous"></script></head><body class="antialiased"><div id="__next"><script>!function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');var e=localStorage.getItem('theme');if('system'===e||(!e&&true)){var t='(prefers-color-scheme: dark)',m=window.matchMedia(t);if(m.media!==t||m.matches){d.style.colorScheme = 'dark';c.add('dark')}else{d.style.colorScheme = 'light';c.add('light')}}else if(e){c.add(e|| '')}if(e==='light'||e==='dark')d.style.colorScheme=e}catch(e){}}()</script><div class="relative z-0 flex h-full w-full overflow-hidden"><div class="relative flex h-full max-w-full flex-1 flex-col overflow-hidden"><main class="relative h-full w-full flex-1 overflow-auto transition-width"></main></div></div><div class="absolute left-0 right-0 top-0 z-[2]"></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="anonymous">{"props":{"pageProps":{"serverPrimedAllowBrowserStorageValue":true,"isStorageComplianceEnabled":false,"sharedConversationId":"a22dee7a-0707-43f0-89c7-0da31be71a6b","serverResponse":{"type":"data","data":{"title":"5Portée des Variables dans les Lambdas","create_time":1706692965.108712,"update_time":1706692970,"mapping":{"1cd11d7a-edb8-48c3-9a1e-e722cf4ec6df":{"id":"1cd11d7a-edb8-48c3-9a1e-e722cf4ec6df","message":{"id":"1cd11d7a-edb8-48c3-9a1e-e722cf4ec6df","author":{"role":"assistant","metadata":{}},"create_time":1706692950.881853,"content":{"content_type":"text","parts":["### 4. Portée Lexicale\n\n#### 4.1. Définition\n\nLa portée lexicale, également connue sous le nom de portée statique, est un concept lié à la façon dont les variables sont résolues dans un programme. En Python, la portée lexicale signifie que la résolution des variables dépend de la structure du code source, c'est-à-dire de la façon dont le code est écrit.\n\nDans une portée lexicale, la recherche de la valeur d'une variable se fait en remontant la chaîne des portées définies dans le code source. Cela signifie qu'une variable est résolue dans le contexte dans lequel elle est définie, et non dans celui où elle est exécutée.\n\n#### 4.2. Comparaison avec la Portée Dynamique\n\nLa portée lexicale se distingue de la portée dynamique, où la résolution des variables dépend de l'ordre d'exécution du programme. En portée dynamique, la recherche de la valeur d'une variable se fait en fonction de l'ordre d'appel des fonctions ou des blocs de code.\n\nEn Python, la portée lexicale est utilisée, ce qui signifie que lorsque vous référencez une variable à l'intérieur d'une fonction, Python la recherche d'abord dans la fonction elle-même, puis dans la fonction englobante (si elle existe), et ainsi de suite, jusqu'à atteindre le niveau global.\n\n#### 4.3. Impact sur les Lambdas\n\nLa portée lexicale a un impact significatif sur les lambdas, car les lambdas capturent les variables de leur portée lexicale d'origine. Cela signifie que même si une lambda est exécutée dans un contexte différent, elle utilise toujours les valeurs des variables telles qu'elles étaient au moment de sa création.\n\n##### Exemple 1: Utilisation de la portée lexicale avec une lambda\n\n```python\ndef outer_function(x):\n    # Lambda qui capture la variable x de la portée lexicale de outer_function\n    return lambda y: x + y\n\n# Créer une closure avec la fonction externe\nclosure_instance = outer_function(10)\n\n# Utiliser la closure\nresult = closure_instance(5)\nprint(result)  # Output: 15\n```\n\nDans cet exemple, la lambda à l'intérieur de la fonction `outer_function` capture la variable `x` de la portée lexicale de `outer_function`. Même si `outer_function` a terminé son exécution, la closure conserve la référence à `x`.\n\nLa portée lexicale est un concept fondamental en programmation qui contribue à la prévisibilité du comportement des variables, en particulier dans des contextes fonctionnels tels que les lambdas et les closures. Cela facilite la compréhension du code et évite les erreurs liées à la portée des variables."]},"status":"finished_successfully","end_turn":true,"weight":1,"metadata":{"finish_details":{"type":"stop","stop_tokens":[100260]},"is_complete":true,"model_slug":"text-davinci-002-render-sha","parent_id":"aaa244a2-24f4-41e8-b339-7d6d74c5c847","timestamp_":"absolute","shared_conversation_id":"a22dee7a-0707-43f0-89c7-0da31be71a6b"},"recipient":"all"},"parent":"aaa244a2-24f4-41e8-b339-7d6d74c5c847","children":[]},"aaa244a2-24f4-41e8-b339-7d6d74c5c847":{"id":"aaa244a2-24f4-41e8-b339-7d6d74c5c847","message":{"id":"aaa244a2-24f4-41e8-b339-7d6d74c5c847","author":{"role":"user","metadata":{}},"create_time":1706692925.209694,"content":{"content_type":"text","parts":["tuto complet et approfondit  PYTHON  : Portée LEXICALE : \n4.1. Définition\n4.2. Comparaison avec la Portée Dynamique\n4.3. Impact sur les Lambdas"]},"status":"finished_successfully","weight":1,"metadata":{"timestamp_":"absolute","shared_conversation_id":"a22dee7a-0707-43f0-89c7-0da31be71a6b"},"recipient":"all"},"parent":"4244bf9a-bc3e-41a3-8a2d-dcb215b0d7fe","children":["1cd11d7a-edb8-48c3-9a1e-e722cf4ec6df"]},"4244bf9a-bc3e-41a3-8a2d-dcb215b0d7fe":{"id":"4244bf9a-bc3e-41a3-8a2d-dcb215b0d7fe","message":{"id":"4244bf9a-bc3e-41a3-8a2d-dcb215b0d7fe","author":{"role":"assistant","metadata":{}},"create_time":1706692918.903545,"content":{"content_type":"text","parts":["### 3. Closures\n\n#### 3.1. Définition\n\nLes closures sont des fonctions imbriquées qui capturent et mémorisent les variables dans la portée englobante, même si la portée englobante n'est plus active. En d'autres termes, une closure permet à une fonction interne d'accéder aux variables de sa fonction externe même après que cette fonction externe ait terminé son exécution.\n\n#### 3.2. Utilisation des Closures avec Lambdas\n\nLes closures sont souvent utilisées avec des lambdas pour créer des fonctions plus flexibles et puissantes. L'utilisation de closures avec des lambdas permet de créer des fonctions rapidement sans avoir à définir une fonction distincte.\n\n##### Exemple 1: Closure avec Lambda\n\n```python\ndef outer_function(x):\n    # La fonction interne est une closure qui capture la variable x de la portée englobante\n    return lambda y: x + y\n\n# Créer une closure avec la fonction externe\nclosure_instance = outer_function(10)\n\n# Utiliser la closure\nresult = closure_instance(5)\nprint(result)  # Output: 15\n```\n\nDans cet exemple, la fonction `outer_function` retourne une lambda qui capture la variable `x` de la portée englobante. Lorsque la closure est créée avec `outer_function(10)`, elle conserve la valeur de `x` même après que `outer_function` ait terminé son exécution.\n\n#### 3.3. Exemples de Closures\n\n##### Exemple 2: Utilisation de Closure pour créer des fonctions spécifiques\n\n```python\ndef power_of(base):\n    # Closure qui capture la variable base\n    return lambda exponent: base ** exponent\n\n# Créer des fonctions spécifiques en utilisant la closure\nsquare = power_of(2)\ncube = power_of(3)\n\n# Utiliser les fonctions spécifiques\nprint(square(3))  # Output: 8\nprint(cube(2))    # Output: 9\n```\n\nIci, la closure `lambda exponent: base ** exponent` capture la variable `base` de la fonction externe `power_of`. Cela permet de créer des fonctions spécifiques (comme `square` et `cube`) en utilisant la closure avec différentes valeurs de `base`.\n\n##### Exemple 3: Gestion de l'état avec une Closure\n\n```python\ndef counter():\n    count = 0\n\n    def increment():\n        nonlocal count\n        count += 1\n        return count\n\n    return increment\n\n# Créer une closure pour le compteur\ncounter_instance = counter()\n\n# Utiliser la closure pour incrémenter le compteur\nprint(counter_instance())  # Output: 1\nprint(counter_instance())  # Output: 2\nprint(counter_instance())  # Output: 3\n```\n\nDans cet exemple, la closure `increment` capture la variable `count` de la fonction englobante `counter`. Chaque fois que la closure est appelée, elle incrémente et retourne la valeur du compteur.\n\nLes closures sont particulièrement utiles pour créer des fonctions avec des comportements spécifiques, gérer l'état, et permettent une encapsulation efficace des variables dans des contextes fonctionnels. Les lambdas et les closures sont des concepts puissants en Python qui peuvent rendre votre code plus concis et plus expressif."]},"status":"finished_successfully","end_turn":true,"weight":1,"metadata":{"finish_details":{"type":"stop","stop_tokens":[100260]},"is_complete":true,"model_slug":"text-davinci-002-render-sha","parent_id":"aaa29950-da71-4df7-83a1-b1378c58b545","timestamp_":"absolute","shared_conversation_id":"a22dee7a-0707-43f0-89c7-0da31be71a6b"},"recipient":"all"},"parent":"aaa29950-da71-4df7-83a1-b1378c58b545","children":["aaa244a2-24f4-41e8-b339-7d6d74c5c847"]},"aaa29950-da71-4df7-83a1-b1378c58b545":{"id":"aaa29950-da71-4df7-83a1-b1378c58b545","message":{"id":"aaa29950-da71-4df7-83a1-b1378c58b545","author":{"role":"user","metadata":{}},"create_time":1706692889.221124,"content":{"content_type":"text","parts":["tuto complet et approfondit  PYTHON  : Closures : \n3.1. Définition\n3.2. Utilisation des Closures avec Lambdas\n3.3. Exemples de Closures"]},"status":"finished_successfully","weight":1,"metadata":{"timestamp_":"absolute","shared_conversation_id":"a22dee7a-0707-43f0-89c7-0da31be71a6b"},"recipient":"all"},"parent":"fc0a7a66-404f-417c-a6cb-3981624b8ed1","children":["4244bf9a-bc3e-41a3-8a2d-dcb215b0d7fe"]},"fc0a7a66-404f-417c-a6cb-3981624b8ed1":{"id":"fc0a7a66-404f-417c-a6cb-3981624b8ed1","message":{"id":"fc0a7a66-404f-417c-a6cb-3981624b8ed1","author":{"role":"assistant","metadata":{}},"create_time":1706692887.014093,"content":{"content_type":"text","parts":["### 2.2. Variables Non-locales\n\n#### 2.2.1. Définition de Variables Non-locales\n\nLes variables non-locales sont des variables qui ne sont ni locales à une fonction ni globales. Elles sont généralement utilisées dans le contexte de fonctions imbriquées (fonctions définies à l'intérieur d'autres fonctions) pour accéder et modifier des variables situées dans la portée englobante, mais qui ne sont pas globales.\n\n#### 2.2.2. Utilisation de la Déclaration nonlocal\n\nEn Python, pour indiquer qu'une variable à l'intérieur d'une fonction est non-locale (c'est-à-dire qu'elle se réfère à une variable de la portée englobante, mais n'est pas globale), on utilise la déclaration `nonlocal`.\n\n```python\ndef outer_function():\n    x = 10  # Variable dans la portée englobante\n\n    def inner_function():\n        nonlocal x  # Déclaration nonlocal pour indiquer l'utilisation de la variable englobante\n        x += 5\n        print(\"Inner function:\", x)\n\n    inner_function()\n    print(\"Outer function:\", x)\n\n# Appeler la fonction externe\nouter_function()\n```\n\nDans cet exemple, la variable `x` est définie dans la fonction englobante (`outer_function`). La fonction interne (`inner_function`) utilise la déclaration `nonlocal` pour indiquer qu'elle veut utiliser la variable `x` de la portée englobante.\n\n#### 2.2.3. Exemples de Variables Non-locales\n\nIllustrons cela avec quelques exemples concrets.\n\n##### Exemple 1: Modification d'une variable non-locale\n\n```python\ndef outer_function():\n    count = 0\n\n    def increment():\n        nonlocal count\n        count += 1\n        print(\"Count inside increment function:\", count)\n\n    increment()\n    print(\"Count outside increment function:\", count)\n\n# Appeler la fonction externe\nouter_function()\n```\n\nDans cet exemple, la fonction `increment` modifie la variable non-locale `count` de la fonction englobante.\n\n##### Exemple 2: Utilisation de variables non-locales dans une boucle\n\n```python\ndef outer_function():\n    total = 0\n\n    def add_numbers(numbers):\n        nonlocal total\n        for num in numbers:\n            total += num\n        print(\"Total inside add_numbers function:\", total)\n\n    add_numbers([1, 2, 3])\n    print(\"Total outside add_numbers function:\", total)\n\n# Appeler la fonction externe\nouter_function()\n```\n\nIci, la fonction interne `add_numbers` utilise la variable non-locale `total` de la fonction englobante pour calculer la somme des nombres dans une liste.\n\nComprendre l'utilisation des variables non-locales est essentiel lorsque vous travaillez avec des fonctions imbriquées, car cela permet de manipuler des variables de la portée englobante sans créer de variables globales. Cela contribue à une conception de code plus modulaire et à une meilleure encapsulation."]},"status":"finished_successfully","end_turn":true,"weight":1,"metadata":{"finish_details":{"type":"stop","stop_tokens":[100260]},"is_complete":true,"model_slug":"text-davinci-002-render-sha","parent_id":"aaa225aa-674e-465d-97ec-5b0b8b68edcc","timestamp_":"absolute","shared_conversation_id":"a22dee7a-0707-43f0-89c7-0da31be71a6b"},"recipient":"all"},"parent":"aaa225aa-674e-465d-97ec-5b0b8b68edcc","children":["aaa29950-da71-4df7-83a1-b1378c58b545"]},"aaa225aa-674e-465d-97ec-5b0b8b68edcc":{"id":"aaa225aa-674e-465d-97ec-5b0b8b68edcc","message":{"id":"aaa225aa-674e-465d-97ec-5b0b8b68edcc","author":{"role":"user","metadata":{}},"create_time":1706692862.075489,"content":{"content_type":"text","parts":["tuto complet et approfondit  PYTHON  : 2.2. Variables Non-locales\n2.2.1. Définition de Variables Non-locales\n2.2.2. Utilisation de la Déclaration nonlocal\n2.2.3. Exemples de Variables Non-locales"]},"status":"finished_successfully","weight":1,"metadata":{"timestamp_":"absolute","shared_conversation_id":"a22dee7a-0707-43f0-89c7-0da31be71a6b"},"recipient":"all"},"parent":"71916b57-c40b-4336-b655-a1e304cf217b","children":["fc0a7a66-404f-417c-a6cb-3981624b8ed1"]},"71916b57-c40b-4336-b655-a1e304cf217b":{"id":"71916b57-c40b-4336-b655-a1e304cf217b","message":{"id":"71916b57-c40b-4336-b655-a1e304cf217b","author":{"role":"assistant","metadata":{}},"create_time":1706692859.731082,"content":{"content_type":"text","parts":["Bien sûr, je serai ravi de vous fournir un tutoriel approfondi sur la portée des variables en Python, en mettant particulièrement l'accent sur les variables locales dans les lambdas. Commençons par définir les termes et concepts clés.\n\n### 2.1. Variables Locales dans les Lambdas\n\n#### 2.1.1. Définition de Variables Locales\n\nEn programmation, la portée d'une variable fait référence à la partie du programme dans laquelle la variable peut être utilisée ou modifiée. Les variables locales sont définies à l'intérieur d'une fonction (ou d'un lambda dans notre cas) et ne sont accessibles que dans cette fonction.\n\nLes lambdas, également appelées fonctions anonymes, sont des fonctions sans nom. Elles peuvent prendre n'importe quel nombre d'arguments, mais elles ne peuvent contenir qu'une seule expression. Les variables locales dans les lambdas sont limitées à la portée de ces fonctions.\n\n#### 2.1.2. Exemples Pratiques\n\nIllustrons cela avec quelques exemples pratiques.\n\n##### Exemple 1: Lambda simple avec une variable locale\n\n```python\n# Définir une lambda avec une variable locale\nlambda_function = lambda x: x + 10\n\n# Utiliser la lambda\nresult = lambda_function(5)\nprint(result)  # Output: 15\n```\n\nIci, la variable `x` est une variable locale à la lambda, et elle ne peut être utilisée en dehors de la lambda.\n\n##### Exemple 2: Utilisation de variables locales multiples dans une lambda\n\n```python\n# Définir une lambda avec plusieurs variables locales\nmultiply = lambda x, y: x * y\n\n# Utiliser la lambda\nresult = multiply(3, 4)\nprint(result)  # Output: 12\n```\n\nDans cet exemple, `x` et `y` sont toutes deux des variables locales pour la lambda.\n\n##### Exemple 3: Utilisation de variables locales dans une portée plus large\n\n```python\ndef outer_function():\n    # Définir une lambda à l'intérieur d'une fonction\n    inner_lambda = lambda a, b: a + b\n\n    # Utiliser la lambda\n    result = inner_lambda(10, 20)\n    print(result)  # Output: 30\n\n# Appeler la fonction externe\nouter_function()\n```\n\nDans cet exemple, la lambda est définie à l'intérieur d'une fonction (`outer_function`), mais elle reste locale à cette fonction.\n\nCela illustre comment les lambdas en Python peuvent utiliser des variables locales et comment ces variables ne sont généralement pas accessibles en dehors de la fonction (ou lambda) dans laquelle elles sont définies. La portée des variables est un concept fondamental en programmation, et comprendre comment cela fonctionne en Python est essentiel pour écrire un code propre et éviter les erreurs liées à la portée des variables."]},"status":"finished_successfully","end_turn":true,"weight":1,"metadata":{"finish_details":{"type":"stop","stop_tokens":[100260]},"is_complete":true,"model_slug":"text-davinci-002-render-sha","parent_id":"aaa22294-a438-4c10-ab5e-24f02a972979","timestamp_":"absolute","shared_conversation_id":"a22dee7a-0707-43f0-89c7-0da31be71a6b"},"recipient":"all"},"parent":"aaa22294-a438-4c10-ab5e-24f02a972979","children":["aaa225aa-674e-465d-97ec-5b0b8b68edcc"]},"aaa22294-a438-4c10-ab5e-24f02a972979":{"id":"aaa22294-a438-4c10-ab5e-24f02a972979","message":{"id":"aaa22294-a438-4c10-ab5e-24f02a972979","author":{"role":"user","metadata":{}},"create_time":1706692832.916846,"content":{"content_type":"text","parts":["tuto complet et approfondit  PYTHON  : Portée des Variables : \n2.1. Variables Locales dans les Lambdas\n2.1.1. Définition de Variables Locales\n2.1.2. Exemples Pratiques"]},"status":"finished_successfully","weight":1,"metadata":{"timestamp_":"absolute","shared_conversation_id":"a22dee7a-0707-43f0-89c7-0da31be71a6b"},"recipient":"all"},"parent":"78cb50e2-83f2-4199-a2c2-1156ac5c800c","children":["71916b57-c40b-4336-b655-a1e304cf217b"]},"78cb50e2-83f2-4199-a2c2-1156ac5c800c":{"id":"78cb50e2-83f2-4199-a2c2-1156ac5c800c","message":{"id":"78cb50e2-83f2-4199-a2c2-1156ac5c800c","author":{"role":"system","metadata":{}},"content":{"content_type":"text","parts":[""]},"status":"finished_successfully","end_turn":true,"weight":0,"metadata":{"is_visually_hidden_from_conversation":true,"shared_conversation_id":"a22dee7a-0707-43f0-89c7-0da31be71a6b"},"recipient":"all"},"parent":"aaa1b615-4bb0-4bb4-8292-e486f3a16960","children":["aaa22294-a438-4c10-ab5e-24f02a972979"]},"aaa1b615-4bb0-4bb4-8292-e486f3a16960":{"id":"aaa1b615-4bb0-4bb4-8292-e486f3a16960","children":["78cb50e2-83f2-4199-a2c2-1156ac5c800c"]}},"moderation_results":[],"current_node":"1cd11d7a-edb8-48c3-9a1e-e722cf4ec6df","conversation_id":"a22dee7a-0707-43f0-89c7-0da31be71a6b","is_archived":false,"safe_urls":[],"is_public":true,"linear_conversation":[{"id":"aaa1b615-4bb0-4bb4-8292-e486f3a16960","children":["78cb50e2-83f2-4199-a2c2-1156ac5c800c"]},{"id":"78cb50e2-83f2-4199-a2c2-1156ac5c800c","message":{"id":"78cb50e2-83f2-4199-a2c2-1156ac5c800c","author":{"role":"system","metadata":{}},"content":{"content_type":"text","parts":[""]},"status":"finished_successfully","end_turn":true,"weight":0,"metadata":{"is_visually_hidden_from_conversation":true,"shared_conversation_id":"a22dee7a-0707-43f0-89c7-0da31be71a6b"},"recipient":"all"},"parent":"aaa1b615-4bb0-4bb4-8292-e486f3a16960","children":["aaa22294-a438-4c10-ab5e-24f02a972979"]},{"id":"aaa22294-a438-4c10-ab5e-24f02a972979","message":{"id":"aaa22294-a438-4c10-ab5e-24f02a972979","author":{"role":"user","metadata":{}},"create_time":1706692832.916846,"content":{"content_type":"text","parts":["tuto complet et approfondit  PYTHON  : Portée des Variables : \n2.1. Variables Locales dans les Lambdas\n2.1.1. Définition de Variables Locales\n2.1.2. Exemples Pratiques"]},"status":"finished_successfully","weight":1,"metadata":{"timestamp_":"absolute","shared_conversation_id":"a22dee7a-0707-43f0-89c7-0da31be71a6b"},"recipient":"all"},"parent":"78cb50e2-83f2-4199-a2c2-1156ac5c800c","children":["71916b57-c40b-4336-b655-a1e304cf217b"]},{"id":"71916b57-c40b-4336-b655-a1e304cf217b","message":{"id":"71916b57-c40b-4336-b655-a1e304cf217b","author":{"role":"assistant","metadata":{}},"create_time":1706692859.731082,"content":{"content_type":"text","parts":["Bien sûr, je serai ravi de vous fournir un tutoriel approfondi sur la portée des variables en Python, en mettant particulièrement l'accent sur les variables locales dans les lambdas. Commençons par définir les termes et concepts clés.\n\n### 2.1. Variables Locales dans les Lambdas\n\n#### 2.1.1. Définition de Variables Locales\n\nEn programmation, la portée d'une variable fait référence à la partie du programme dans laquelle la variable peut être utilisée ou modifiée. Les variables locales sont définies à l'intérieur d'une fonction (ou d'un lambda dans notre cas) et ne sont accessibles que dans cette fonction.\n\nLes lambdas, également appelées fonctions anonymes, sont des fonctions sans nom. Elles peuvent prendre n'importe quel nombre d'arguments, mais elles ne peuvent contenir qu'une seule expression. Les variables locales dans les lambdas sont limitées à la portée de ces fonctions.\n\n#### 2.1.2. Exemples Pratiques\n\nIllustrons cela avec quelques exemples pratiques.\n\n##### Exemple 1: Lambda simple avec une variable locale\n\n```python\n# Définir une lambda avec une variable locale\nlambda_function = lambda x: x + 10\n\n# Utiliser la lambda\nresult = lambda_function(5)\nprint(result)  # Output: 15\n```\n\nIci, la variable `x` est une variable locale à la lambda, et elle ne peut être utilisée en dehors de la lambda.\n\n##### Exemple 2: Utilisation de variables locales multiples dans une lambda\n\n```python\n# Définir une lambda avec plusieurs variables locales\nmultiply = lambda x, y: x * y\n\n# Utiliser la lambda\nresult = multiply(3, 4)\nprint(result)  # Output: 12\n```\n\nDans cet exemple, `x` et `y` sont toutes deux des variables locales pour la lambda.\n\n##### Exemple 3: Utilisation de variables locales dans une portée plus large\n\n```python\ndef outer_function():\n    # Définir une lambda à l'intérieur d'une fonction\n    inner_lambda = lambda a, b: a + b\n\n    # Utiliser la lambda\n    result = inner_lambda(10, 20)\n    print(result)  # Output: 30\n\n# Appeler la fonction externe\nouter_function()\n```\n\nDans cet exemple, la lambda est définie à l'intérieur d'une fonction (`outer_function`), mais elle reste locale à cette fonction.\n\nCela illustre comment les lambdas en Python peuvent utiliser des variables locales et comment ces variables ne sont généralement pas accessibles en dehors de la fonction (ou lambda) dans laquelle elles sont définies. La portée des variables est un concept fondamental en programmation, et comprendre comment cela fonctionne en Python est essentiel pour écrire un code propre et éviter les erreurs liées à la portée des variables."]},"status":"finished_successfully","end_turn":true,"weight":1,"metadata":{"finish_details":{"type":"stop","stop_tokens":[100260]},"is_complete":true,"model_slug":"text-davinci-002-render-sha","parent_id":"aaa22294-a438-4c10-ab5e-24f02a972979","timestamp_":"absolute","shared_conversation_id":"a22dee7a-0707-43f0-89c7-0da31be71a6b"},"recipient":"all"},"parent":"aaa22294-a438-4c10-ab5e-24f02a972979","children":["aaa225aa-674e-465d-97ec-5b0b8b68edcc"]},{"id":"aaa225aa-674e-465d-97ec-5b0b8b68edcc","message":{"id":"aaa225aa-674e-465d-97ec-5b0b8b68edcc","author":{"role":"user","metadata":{}},"create_time":1706692862.075489,"content":{"content_type":"text","parts":["tuto complet et approfondit  PYTHON  : 2.2. Variables Non-locales\n2.2.1. Définition de Variables Non-locales\n2.2.2. Utilisation de la Déclaration nonlocal\n2.2.3. Exemples de Variables Non-locales"]},"status":"finished_successfully","weight":1,"metadata":{"timestamp_":"absolute","shared_conversation_id":"a22dee7a-0707-43f0-89c7-0da31be71a6b"},"recipient":"all"},"parent":"71916b57-c40b-4336-b655-a1e304cf217b","children":["fc0a7a66-404f-417c-a6cb-3981624b8ed1"]},{"id":"fc0a7a66-404f-417c-a6cb-3981624b8ed1","message":{"id":"fc0a7a66-404f-417c-a6cb-3981624b8ed1","author":{"role":"assistant","metadata":{}},"create_time":1706692887.014093,"content":{"content_type":"text","parts":["### 2.2. Variables Non-locales\n\n#### 2.2.1. Définition de Variables Non-locales\n\nLes variables non-locales sont des variables qui ne sont ni locales à une fonction ni globales. Elles sont généralement utilisées dans le contexte de fonctions imbriquées (fonctions définies à l'intérieur d'autres fonctions) pour accéder et modifier des variables situées dans la portée englobante, mais qui ne sont pas globales.\n\n#### 2.2.2. Utilisation de la Déclaration nonlocal\n\nEn Python, pour indiquer qu'une variable à l'intérieur d'une fonction est non-locale (c'est-à-dire qu'elle se réfère à une variable de la portée englobante, mais n'est pas globale), on utilise la déclaration `nonlocal`.\n\n```python\ndef outer_function():\n    x = 10  # Variable dans la portée englobante\n\n    def inner_function():\n        nonlocal x  # Déclaration nonlocal pour indiquer l'utilisation de la variable englobante\n        x += 5\n        print(\"Inner function:\", x)\n\n    inner_function()\n    print(\"Outer function:\", x)\n\n# Appeler la fonction externe\nouter_function()\n```\n\nDans cet exemple, la variable `x` est définie dans la fonction englobante (`outer_function`). La fonction interne (`inner_function`) utilise la déclaration `nonlocal` pour indiquer qu'elle veut utiliser la variable `x` de la portée englobante.\n\n#### 2.2.3. Exemples de Variables Non-locales\n\nIllustrons cela avec quelques exemples concrets.\n\n##### Exemple 1: Modification d'une variable non-locale\n\n```python\ndef outer_function():\n    count = 0\n\n    def increment():\n        nonlocal count\n        count += 1\n        print(\"Count inside increment function:\", count)\n\n    increment()\n    print(\"Count outside increment function:\", count)\n\n# Appeler la fonction externe\nouter_function()\n```\n\nDans cet exemple, la fonction `increment` modifie la variable non-locale `count` de la fonction englobante.\n\n##### Exemple 2: Utilisation de variables non-locales dans une boucle\n\n```python\ndef outer_function():\n    total = 0\n\n    def add_numbers(numbers):\n        nonlocal total\n        for num in numbers:\n            total += num\n        print(\"Total inside add_numbers function:\", total)\n\n    add_numbers([1, 2, 3])\n    print(\"Total outside add_numbers function:\", total)\n\n# Appeler la fonction externe\nouter_function()\n```\n\nIci, la fonction interne `add_numbers` utilise la variable non-locale `total` de la fonction englobante pour calculer la somme des nombres dans une liste.\n\nComprendre l'utilisation des variables non-locales est essentiel lorsque vous travaillez avec des fonctions imbriquées, car cela permet de manipuler des variables de la portée englobante sans créer de variables globales. Cela contribue à une conception de code plus modulaire et à une meilleure encapsulation."]},"status":"finished_successfully","end_turn":true,"weight":1,"metadata":{"finish_details":{"type":"stop","stop_tokens":[100260]},"is_complete":true,"model_slug":"text-davinci-002-render-sha","parent_id":"aaa225aa-674e-465d-97ec-5b0b8b68edcc","timestamp_":"absolute","shared_conversation_id":"a22dee7a-0707-43f0-89c7-0da31be71a6b"},"recipient":"all"},"parent":"aaa225aa-674e-465d-97ec-5b0b8b68edcc","children":["aaa29950-da71-4df7-83a1-b1378c58b545"]},{"id":"aaa29950-da71-4df7-83a1-b1378c58b545","message":{"id":"aaa29950-da71-4df7-83a1-b1378c58b545","author":{"role":"user","metadata":{}},"create_time":1706692889.221124,"content":{"content_type":"text","parts":["tuto complet et approfondit  PYTHON  : Closures : \n3.1. Définition\n3.2. Utilisation des Closures avec Lambdas\n3.3. Exemples de Closures"]},"status":"finished_successfully","weight":1,"metadata":{"timestamp_":"absolute","shared_conversation_id":"a22dee7a-0707-43f0-89c7-0da31be71a6b"},"recipient":"all"},"parent":"fc0a7a66-404f-417c-a6cb-3981624b8ed1","children":["4244bf9a-bc3e-41a3-8a2d-dcb215b0d7fe"]},{"id":"4244bf9a-bc3e-41a3-8a2d-dcb215b0d7fe","message":{"id":"4244bf9a-bc3e-41a3-8a2d-dcb215b0d7fe","author":{"role":"assistant","metadata":{}},"create_time":1706692918.903545,"content":{"content_type":"text","parts":["### 3. Closures\n\n#### 3.1. Définition\n\nLes closures sont des fonctions imbriquées qui capturent et mémorisent les variables dans la portée englobante, même si la portée englobante n'est plus active. En d'autres termes, une closure permet à une fonction interne d'accéder aux variables de sa fonction externe même après que cette fonction externe ait terminé son exécution.\n\n#### 3.2. Utilisation des Closures avec Lambdas\n\nLes closures sont souvent utilisées avec des lambdas pour créer des fonctions plus flexibles et puissantes. L'utilisation de closures avec des lambdas permet de créer des fonctions rapidement sans avoir à définir une fonction distincte.\n\n##### Exemple 1: Closure avec Lambda\n\n```python\ndef outer_function(x):\n    # La fonction interne est une closure qui capture la variable x de la portée englobante\n    return lambda y: x + y\n\n# Créer une closure avec la fonction externe\nclosure_instance = outer_function(10)\n\n# Utiliser la closure\nresult = closure_instance(5)\nprint(result)  # Output: 15\n```\n\nDans cet exemple, la fonction `outer_function` retourne une lambda qui capture la variable `x` de la portée englobante. Lorsque la closure est créée avec `outer_function(10)`, elle conserve la valeur de `x` même après que `outer_function` ait terminé son exécution.\n\n#### 3.3. Exemples de Closures\n\n##### Exemple 2: Utilisation de Closure pour créer des fonctions spécifiques\n\n```python\ndef power_of(base):\n    # Closure qui capture la variable base\n    return lambda exponent: base ** exponent\n\n# Créer des fonctions spécifiques en utilisant la closure\nsquare = power_of(2)\ncube = power_of(3)\n\n# Utiliser les fonctions spécifiques\nprint(square(3))  # Output: 8\nprint(cube(2))    # Output: 9\n```\n\nIci, la closure `lambda exponent: base ** exponent` capture la variable `base` de la fonction externe `power_of`. Cela permet de créer des fonctions spécifiques (comme `square` et `cube`) en utilisant la closure avec différentes valeurs de `base`.\n\n##### Exemple 3: Gestion de l'état avec une Closure\n\n```python\ndef counter():\n    count = 0\n\n    def increment():\n        nonlocal count\n        count += 1\n        return count\n\n    return increment\n\n# Créer une closure pour le compteur\ncounter_instance = counter()\n\n# Utiliser la closure pour incrémenter le compteur\nprint(counter_instance())  # Output: 1\nprint(counter_instance())  # Output: 2\nprint(counter_instance())  # Output: 3\n```\n\nDans cet exemple, la closure `increment` capture la variable `count` de la fonction englobante `counter`. Chaque fois que la closure est appelée, elle incrémente et retourne la valeur du compteur.\n\nLes closures sont particulièrement utiles pour créer des fonctions avec des comportements spécifiques, gérer l'état, et permettent une encapsulation efficace des variables dans des contextes fonctionnels. Les lambdas et les closures sont des concepts puissants en Python qui peuvent rendre votre code plus concis et plus expressif."]},"status":"finished_successfully","end_turn":true,"weight":1,"metadata":{"finish_details":{"type":"stop","stop_tokens":[100260]},"is_complete":true,"model_slug":"text-davinci-002-render-sha","parent_id":"aaa29950-da71-4df7-83a1-b1378c58b545","timestamp_":"absolute","shared_conversation_id":"a22dee7a-0707-43f0-89c7-0da31be71a6b"},"recipient":"all"},"parent":"aaa29950-da71-4df7-83a1-b1378c58b545","children":["aaa244a2-24f4-41e8-b339-7d6d74c5c847"]},{"id":"aaa244a2-24f4-41e8-b339-7d6d74c5c847","message":{"id":"aaa244a2-24f4-41e8-b339-7d6d74c5c847","author":{"role":"user","metadata":{}},"create_time":1706692925.209694,"content":{"content_type":"text","parts":["tuto complet et approfondit  PYTHON  : Portée LEXICALE : \n4.1. Définition\n4.2. Comparaison avec la Portée Dynamique\n4.3. Impact sur les Lambdas"]},"status":"finished_successfully","weight":1,"metadata":{"timestamp_":"absolute","shared_conversation_id":"a22dee7a-0707-43f0-89c7-0da31be71a6b"},"recipient":"all"},"parent":"4244bf9a-bc3e-41a3-8a2d-dcb215b0d7fe","children":["1cd11d7a-edb8-48c3-9a1e-e722cf4ec6df"]},{"id":"1cd11d7a-edb8-48c3-9a1e-e722cf4ec6df","message":{"id":"1cd11d7a-edb8-48c3-9a1e-e722cf4ec6df","author":{"role":"assistant","metadata":{}},"create_time":1706692950.881853,"content":{"content_type":"text","parts":["### 4. Portée Lexicale\n\n#### 4.1. Définition\n\nLa portée lexicale, également connue sous le nom de portée statique, est un concept lié à la façon dont les variables sont résolues dans un programme. En Python, la portée lexicale signifie que la résolution des variables dépend de la structure du code source, c'est-à-dire de la façon dont le code est écrit.\n\nDans une portée lexicale, la recherche de la valeur d'une variable se fait en remontant la chaîne des portées définies dans le code source. Cela signifie qu'une variable est résolue dans le contexte dans lequel elle est définie, et non dans celui où elle est exécutée.\n\n#### 4.2. Comparaison avec la Portée Dynamique\n\nLa portée lexicale se distingue de la portée dynamique, où la résolution des variables dépend de l'ordre d'exécution du programme. En portée dynamique, la recherche de la valeur d'une variable se fait en fonction de l'ordre d'appel des fonctions ou des blocs de code.\n\nEn Python, la portée lexicale est utilisée, ce qui signifie que lorsque vous référencez une variable à l'intérieur d'une fonction, Python la recherche d'abord dans la fonction elle-même, puis dans la fonction englobante (si elle existe), et ainsi de suite, jusqu'à atteindre le niveau global.\n\n#### 4.3. Impact sur les Lambdas\n\nLa portée lexicale a un impact significatif sur les lambdas, car les lambdas capturent les variables de leur portée lexicale d'origine. Cela signifie que même si une lambda est exécutée dans un contexte différent, elle utilise toujours les valeurs des variables telles qu'elles étaient au moment de sa création.\n\n##### Exemple 1: Utilisation de la portée lexicale avec une lambda\n\n```python\ndef outer_function(x):\n    # Lambda qui capture la variable x de la portée lexicale de outer_function\n    return lambda y: x + y\n\n# Créer une closure avec la fonction externe\nclosure_instance = outer_function(10)\n\n# Utiliser la closure\nresult = closure_instance(5)\nprint(result)  # Output: 15\n```\n\nDans cet exemple, la lambda à l'intérieur de la fonction `outer_function` capture la variable `x` de la portée lexicale de `outer_function`. Même si `outer_function` a terminé son exécution, la closure conserve la référence à `x`.\n\nLa portée lexicale est un concept fondamental en programmation qui contribue à la prévisibilité du comportement des variables, en particulier dans des contextes fonctionnels tels que les lambdas et les closures. Cela facilite la compréhension du code et évite les erreurs liées à la portée des variables."]},"status":"finished_successfully","end_turn":true,"weight":1,"metadata":{"finish_details":{"type":"stop","stop_tokens":[100260]},"is_complete":true,"model_slug":"text-davinci-002-render-sha","parent_id":"aaa244a2-24f4-41e8-b339-7d6d74c5c847","timestamp_":"absolute","shared_conversation_id":"a22dee7a-0707-43f0-89c7-0da31be71a6b"},"recipient":"all"},"parent":"aaa244a2-24f4-41e8-b339-7d6d74c5c847","children":[]}],"has_user_editable_context":false,"continue_conversation_url":"https://chat.openai.com/share/a22dee7a-0707-43f0-89c7-0da31be71a6b/continue","model":{"slug":"text-davinci-002-render-sha","max_tokens":8191,"title":"Default (GPT-3.5)","description":"Our fastest model, great for most everyday tasks.","tags":["gpt3.5"]},"moderation_state":{"has_been_moderated":false,"has_been_blocked":false,"has_been_accepted":false,"has_been_auto_blocked":false,"has_been_auto_moderated":false}}},"continueMode":false,"moderationMode":false,"plugins":null,"chatPageProps":{},"isGizmoLive":true},"__N_SSP":true},"page":"/share/[[...shareParams]]","query":{"shareParams":["a22dee7a-0707-43f0-89c7-0da31be71a6b"]},"buildId":"HcJr3AWz9pJF9a2HyS6Cf","assetPrefix":"https://cdn.oaistatic.com","isFallback":false,"gssp":true,"scriptLoader":[]}</script></body></html>